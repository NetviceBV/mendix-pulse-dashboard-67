import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.57.4";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

interface VulnerabilityResult {
  jarFile: string;
  name: string;
  version: string;
  vulnerabilities: any[];
  status: string;
  vulnerabilityCount: number;
  error?: string;
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    // Get user from JWT
    const authHeader = req.headers.get('Authorization')!;
    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);

    if (authError || !user) {
      return new Response(JSON.stringify({ error: 'Unauthorized' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    const { appId, environmentName } = await req.json();

    if (!appId || !environmentName) {
      return new Response(JSON.stringify({ 
        error: 'Missing required parameters: appId and environmentName' 
      }), {
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    console.log(`Starting vulnerability scan for app: ${appId}, environment: ${environmentName}`);

    // Create initial scan record
    const { data: scanData, error: scanError } = await supabase
      .from('vulnerability_scans')
      .insert({
        user_id: user.id,
        app_id: appId,
        environment_name: environmentName,
        scan_status: 'running'
      })
      .select()
      .single();

    if (scanError || !scanData) {
      console.error('Failed to create scan record:', scanError);
      return new Response(JSON.stringify({ error: 'Failed to create scan record' }), {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    const scanId = scanData.id;

    try {
      // Get user's Mendix credentials
      const { data: credentials, error: credError } = await supabase
        .from('mendix_credentials')
        .select('username, api_key')
        .eq('user_id', user.id)
        .limit(1)
        .single();

      if (credError || !credentials) {
        throw new Error('No Mendix credentials found');
      }

      // Use appId directly as it's already in the correct format for Mendix API

      const headers = {
        'Mendix-Username': credentials.username,
        'Mendix-ApiKey': credentials.api_key,
        'User-Agent': 'Mendix-Vulnerability-Scanner/1.0'
      };

      // Step 1: Get packages
      console.log('Fetching packages...');
      const packagesResponse = await fetch(
        `https://deploy.mendix.com/api/1/apps/${appId}/packages`,
        { headers }
      );

      if (!packagesResponse.ok) {
        throw new Error(`Failed to fetch packages: ${packagesResponse.status}`);
      }

      const packages = await packagesResponse.json();
      const successfulPackages = packages
        .filter((pkg: any) => pkg.Status === 'Succeeded')
        .sort((a: any, b: any) => new Date(b.CreationDate).getTime() - new Date(a.CreationDate).getTime());

      if (successfulPackages.length === 0) {
        throw new Error('No successful packages found');
      }

      const latestPackage = successfulPackages[0];
      console.log(`Found latest package: ${latestPackage.PackageId}`);

      // Step 2: Get download URL
      console.log('Getting download URL...');
      const packageInfoResponse = await fetch(
        `https://deploy.mendix.com/api/1/apps/${appId}/packages/${latestPackage.PackageId}?url=true`,
        { headers }
      );

      if (!packageInfoResponse.ok) {
        throw new Error(`Failed to get package info: ${packageInfoResponse.status}`);
      }

      const packageInfo = await packageInfoResponse.json();
      const downloadUrl = packageInfo.Url?.Location;

      if (!downloadUrl) {
        throw new Error('Download URL not available');
      }

      // Step 3: Download and extract package
      console.log('Downloading package...');
      const downloadResponse = await fetch(downloadUrl);
      if (!downloadResponse.ok) {
        throw new Error(`Failed to download package: ${downloadResponse.status}`);
      }

      const packageData = await downloadResponse.arrayBuffer();
      
      console.log('Parsing ZIP structure...');
      
      // Parse ZIP file to find JAR files without subprocess
      const jarFiles = await extractJarFilesFromZip(new Uint8Array(packageData));

        console.log(`Found ${jarFiles.length} JAR files`);

        // Update scan progress
        await supabase
          .from('vulnerability_scans')
          .update({
            total_jars: jarFiles.length,
            package_id: latestPackage.PackageId,
            package_version: latestPackage.Version || 'unknown'
          })
          .eq('id', scanId);

        // Step 4: Check vulnerabilities
        console.log('Checking vulnerabilities...');
        const vulnerabilityResults = await checkVulnerabilities(jarFiles);

        // Save vulnerability findings
        const findings = [];
        for (const result of vulnerabilityResults) {
          for (const vuln of result.vulnerabilities) {
            findings.push({
              scan_id: scanId,
              jar_file: result.jarFile,
              library_name: result.name,
              library_version: result.version,
              vulnerability_id: vuln.id,
              title: vuln.title,
              description: vuln.description,
              cvss_score: vuln.cvssScore,
              cvss_vector: vuln.cvssVector,
              severity: vuln.severity,
              reference_url: vuln.reference,
              published_at: vuln.publishedAt,
              updated_at_vuln: vuln.updatedAt,
              cve_id: vuln.cveId,
              ghsa_id: vuln.ghsaId
            });
          }
        }

        if (findings.length > 0) {
          await supabase.from('vulnerability_findings').insert(findings);
        }

        // Update scan completion
        const summary = {
          vulnerable_jars: vulnerabilityResults.filter(r => r.status === 'vulnerable').length,
          clean_jars: vulnerabilityResults.filter(r => r.status === 'clean').length,
          error_jars: vulnerabilityResults.filter(r => r.status === 'error').length,
          total_vulnerabilities: vulnerabilityResults.reduce((sum, r) => sum + (r.vulnerabilityCount || 0), 0)
        };

        await supabase
          .from('vulnerability_scans')
          .update({
            scan_status: 'completed',
            completed_at: new Date().toISOString(),
            ...summary
          })
          .eq('id', scanId);

        return new Response(JSON.stringify({
          scanId,
          summary: {
            ...summary,
            totalJars: jarFiles.length
          }
        }), {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        });

    } catch (error) {
      console.error('Vulnerability scan error:', error);
      
      // Update scan with error status
      await supabase
        .from('vulnerability_scans')
        .update({
          scan_status: 'failed',
          completed_at: new Date().toISOString(),
          error_message: error instanceof Error ? error.message : 'Unknown error'
        })
        .eq('id', scanId);

      return new Response(JSON.stringify({ 
        error: 'Vulnerability scan failed', 
        message: error instanceof Error ? error.message : 'Unknown error',
        scanId 
      }), {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

  } catch (error) {
    console.error('Error in vulnerability scan:', error);
    return new Response(JSON.stringify({ 
      error: 'Internal server error', 
      message: error instanceof Error ? error.message : 'Unknown error'
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});

async function extractJarFilesFromZip(zipData: Uint8Array): Promise<string[]> {
  const jarFiles: string[] = [];
  
  try {
    // ZIP file format parsing
    // Find End of Central Directory record (EOCD)
    let eocdOffset = -1;
    for (let i = zipData.length - 22; i >= 0; i--) {
      if (zipData[i] === 0x50 && zipData[i + 1] === 0x4b && 
          zipData[i + 2] === 0x05 && zipData[i + 3] === 0x06) {
        eocdOffset = i;
        break;
      }
    }
    
    if (eocdOffset === -1) {
      throw new Error('Invalid ZIP file: End of Central Directory not found');
    }
    
    // Read central directory information from EOCD
    const view = new DataView(zipData.buffer);
    const centralDirSize = view.getUint32(eocdOffset + 12, true);
    const centralDirOffset = view.getUint32(eocdOffset + 16, true);
    const totalEntries = view.getUint16(eocdOffset + 10, true);
    
    console.log(`ZIP contains ${totalEntries} entries`);
    
    // Parse central directory entries
    let currentOffset = centralDirOffset;
    for (let i = 0; i < totalEntries; i++) {
      // Check central file header signature
      if (view.getUint32(currentOffset, true) !== 0x02014b50) {
        console.warn(`Invalid central directory entry at offset ${currentOffset}`);
        break;
      }
      
      // Read filename length
      const filenameLength = view.getUint16(currentOffset + 28, true);
      const extraFieldLength = view.getUint16(currentOffset + 30, true);
      const commentLength = view.getUint16(currentOffset + 32, true);
      
      // Extract filename
      const filenameStart = currentOffset + 46;
      const filenameBytes = zipData.slice(filenameStart, filenameStart + filenameLength);
      const filename = new TextDecoder().decode(filenameBytes);
      
      // Check if it's a JAR file in userlib or any directory
      if (filename.endsWith('.jar')) {
        const jarName = filename.split('/').pop() || filename;
        if (!jarFiles.includes(jarName)) {
          jarFiles.push(jarName);
        }
      }
      
      // Move to next entry
      currentOffset += 46 + filenameLength + extraFieldLength + commentLength;
    }
    
    console.log(`Found ${jarFiles.length} unique JAR files: ${jarFiles.join(', ')}`);
    
  } catch (error) {
    console.error('Error parsing ZIP file:', error);
    const errorMessage = error instanceof Error ? error.message : 'Failed to parse ZIP file';
    throw new Error(`Failed to parse ZIP file: ${errorMessage}`);
  }
  
  return jarFiles;
}

async function checkVulnerabilities(jarFiles: string[]): Promise<VulnerabilityResult[]> {
  const results: VulnerabilityResult[] = [];
  
  console.log(`Processing ${jarFiles.length} JAR files using GitHub Advisory Database`);
  
  for (let i = 0; i < jarFiles.length; i++) {
    const jarFile = jarFiles[i];
    console.log(`Processing ${i + 1}/${jarFiles.length}: ${jarFile}`);
    
    try {
      // Extract library name and version from JAR filename
      const fileName = jarFile.replace('.jar', '');
      
      let name = fileName;
      let version = '';
      
      // Common patterns: library-1.2.3.jar or library-name-1.2.3.jar
      const versionMatch = fileName.match(/^(.+?)-(\d+(?:\.\d+)*(?:-\w+)?)$/);
      if (versionMatch) {
        name = versionMatch[1];
        version = versionMatch[2];
      }
      
      try {
        // Query GitHub Advisory Database API
        const searchUrl = `https://api.github.com/advisories?affects=maven:${name}${version ? `@${version}` : ''}`;
        
        console.log(`Querying GitHub API: ${searchUrl}`);
        
        const githubResponse = await fetch(searchUrl, {
          headers: {
            'Accept': 'application/vnd.github.v3+json',
            'User-Agent': 'Mendix-Vulnerability-Scanner/1.0'
          }
        });
        
        if (!githubResponse.ok) {
          throw new Error(`GitHub API error: ${githubResponse.status}`);
        }
        
        const advisories = await githubResponse.json();
        const advisoryList = Array.isArray(advisories) ? advisories : [];
        
        console.log(`Found ${advisoryList.length} advisories for ${name}`);
        
        results.push({
          jarFile: jarFile,
          name: name,
          version: version || 'unknown',
          vulnerabilities: advisoryList.map((advisory: any) => ({
            id: advisory.ghsa_id || advisory.cve_id || 'Unknown',
            title: advisory.summary || 'Unknown vulnerability',
            description: advisory.description || 'No description available',
            cvssScore: advisory.cvss?.score || 0,
            cvssVector: advisory.cvss?.vector_string || 'Unknown',
            severity: advisory.severity || 'Unknown',
            reference: advisory.html_url || 'No reference available',
            publishedAt: advisory.published_at,
            updatedAt: advisory.updated_at,
            withdrawnAt: advisory.withdrawn_at,
            cveId: advisory.cve_id,
            ghsaId: advisory.ghsa_id
          })),
          status: advisoryList.length > 0 ? 'vulnerable' : 'clean',
          vulnerabilityCount: advisoryList.length
        });
        
      } catch (githubError) {
        console.error(`GitHub API error for ${jarFile}:`, githubError);
        
        results.push({
          jarFile: jarFile,
          name: name,
          version: version || 'unknown',
          vulnerabilities: [],
          status: 'error',
          vulnerabilityCount: 0,
          error: `GitHub API error: ${githubError instanceof Error ? githubError.message : 'Unknown error'}`
        });
      }
      
      // Rate limiting: GitHub API allows 60 requests per hour for unauthenticated
      if (i < jarFiles.length - 1) {
        console.log('Waiting 1 second to respect GitHub API rate limits...');
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
      
    } catch (error) {
      console.error(`Error processing ${jarFile}:`, error);
      results.push({
        jarFile: jarFile,
        name: jarFile,
        version: 'unknown',
        vulnerabilities: [],
        status: 'error',
        vulnerabilityCount: 0,
        error: `Failed to process: ${error instanceof Error ? error.message : 'Unknown error'}`
      });
    }
  }
  
  return results;
}