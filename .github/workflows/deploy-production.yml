name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      confirm_merge:
        description: 'Merge dev to main and deploy to production?'
        required: true
        default: 'no'
        type: choice
        options:
        - 'yes'
        - 'no'

permissions:
  contents: write
  pull-requests: write
  actions: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: github.event.inputs.confirm_merge == 'yes'
    
    steps:
      - name: Checkout dev branch
        uses: actions/checkout@v4
        with:
          ref: dev
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

      - name: Merge dev to main
        run: |
          # Switch to main branch
          git checkout main
          git pull origin main
          
          # Check if there are any differences between dev and main
          if git diff --quiet origin/main origin/dev; then
            echo "â„¹ï¸ No Git changes between dev and main branches"
            echo "GIT_CHANGES=false" >> $GITHUB_ENV
          else
            echo "ðŸ“ Git changes detected - proceeding with merge"
            echo "GIT_CHANGES=true" >> $GITHUB_ENV
            
            # Merge dev into main without committing, excluding client.ts
            git merge origin/dev --no-ff --no-commit || {
              echo "Merge conflict detected, resolving automatically..."
              
              # For workflow file conflicts, use the dev version
              if [ -f .github/workflows/deploy-production.yml ]; then
                git checkout --theirs .github/workflows/deploy-production.yml
              fi
              
              # Mark conflicts as resolved
              git add .
            }
            
            # Restore client.ts from main branch (exclude it from merge)
            git checkout HEAD -- src/integrations/supabase/client.ts 2>/dev/null || echo "client.ts not found, continuing..."
            
            # Check if there are still changes to commit after excluding client.ts
            if git diff --cached --quiet; then
              echo "â„¹ï¸ No changes to commit after excluding client.ts"
              git reset --hard HEAD
              echo "GIT_CHANGES=false" >> $GITHUB_ENV
            else
              # Complete the merge commit
              git commit -m "Deploy: Merge dev to main via GitHub Actions (excluding client.ts)"
              
              # Push the merge to main
              git push origin main
              
              echo "âœ… Successfully merged dev to main (excluding client.ts)"
            fi
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Process only new Lovable migrations for production
        run: |
          echo "Processing only NEW Lovable migrations for production deployment..."
          
          # Create migrations directory if it doesn't exist
          mkdir -p supabase/migrations
          
          # Define cutoff date - migrations before this are problematic and should be skipped
          CUTOFF_DATE="20250924"
          
          echo "Current migration files:"
          ls -la supabase/migrations/*.sql 2>/dev/null || echo "No migration files found"
          
          # Connect to production to check which migrations have already been applied
          echo "Connecting to production to check migration history..."
          supabase link --project-ref ${{ secrets.SUPABASE_PROJECT_REF }} --password ${{ secrets.SUPABASE_DB_PASSWORD }}
          
          # Get list of already applied migrations from production
          echo "Fetching applied migrations from production..."
          APPLIED_MIGRATIONS=$(supabase migration list --linked 2>/dev/null | grep "Applied" | awk '{print $2}' || echo "")
          
          echo "Already applied migrations in production:"
          echo "$APPLIED_MIGRATIONS"
          
          # Create array of applied migration timestamps (extract YYYYMMDDHHMMSS part)
          declare -A applied_map
          while IFS= read -r applied_migration; do
            if [[ -n "$applied_migration" ]]; then
              # Extract timestamp from migration name (first 14 characters: YYYYMMDDHHMMSS)
              timestamp=${applied_migration:0:14}
              applied_map["$timestamp"]=1
              echo "  Already applied: $timestamp"
            fi
          done <<< "$APPLIED_MIGRATIONS"
          
          # Process only NEW migration files that haven't been applied yet
          new_migration_count=0
          NEW_MIGRATIONS_FILE="supabase/migrations/$(date +%Y%m%d%H%M%S)_new_lovable_changes.sql"
          
          echo "-- New Lovable migrations for production" > "$NEW_MIGRATIONS_FILE"
          echo "-- Generated: $(date)" >> "$NEW_MIGRATIONS_FILE"
          echo "-- Only includes migrations not yet applied to production" >> "$NEW_MIGRATIONS_FILE"
          echo "" >> "$NEW_MIGRATIONS_FILE"
          
          for migration_file in supabase/migrations/*.sql; do
            if [ -f "$migration_file" ]; then
              filename=$(basename "$migration_file")
              migration_date=${filename:0:8}
              migration_timestamp=${filename:0:14}
              
              # Skip old problematic migrations
              if [ "$migration_date" -le "$CUTOFF_DATE" ]; then
                echo "Skipping old migration: $filename"
                continue
              fi
              
              # Skip if this migration has already been applied to production
              if [[ -n "${applied_map[$migration_timestamp]}" ]]; then
                echo "Skipping already applied migration: $filename"
                continue
              fi
              
              echo "Processing NEW migration: $filename"
              echo "" >> "$NEW_MIGRATIONS_FILE"
              echo "-- NEW Migration: $filename" >> "$NEW_MIGRATIONS_FILE"
              echo "-- Timestamp: $migration_timestamp" >> "$NEW_MIGRATIONS_FILE"
              
              # Wrap in transaction block with error handling
              echo "DO \$migration_${new_migration_count}\$" >> "$NEW_MIGRATIONS_FILE"
              echo "BEGIN" >> "$NEW_MIGRATIONS_FILE"
              
              # Read and include the SQL content
              while IFS= read -r line; do
                if [[ -n "$line" && ! "$line" =~ ^[[:space:]]*$ ]]; then
                  echo "  $line" >> "$NEW_MIGRATIONS_FILE"
                fi
              done < "$migration_file"
              
              echo "" >> "$NEW_MIGRATIONS_FILE"
              echo "  RAISE NOTICE 'Successfully applied NEW migration: $filename';" >> "$NEW_MIGRATIONS_FILE"
              echo "EXCEPTION" >> "$NEW_MIGRATIONS_FILE"
              echo "  WHEN OTHERS THEN" >> "$NEW_MIGRATIONS_FILE"
              echo "    RAISE WARNING 'Failed to apply migration $filename: %', SQLERRM;" >> "$NEW_MIGRATIONS_FILE"
              echo "END;" >> "$NEW_MIGRATIONS_FILE"
              echo "\$migration_${new_migration_count}\$;" >> "$NEW_MIGRATIONS_FILE"
              echo "" >> "$NEW_MIGRATIONS_FILE"
              
              new_migration_count=$((new_migration_count + 1))
            fi
          done
          
          # Clean up original migration files to avoid conflicts
          rm -f supabase/migrations/202509*.sql
          
          if [ "$new_migration_count" -eq 0 ]; then
            echo "No new migrations to apply - removing empty migration file"
            rm -f "$NEW_MIGRATIONS_FILE"
            echo "SKIP_MIGRATION=true" >> $GITHUB_ENV
          else
            echo ""
            echo "Created migration file with $new_migration_count NEW migrations:"
            ls -la supabase/migrations/
            echo ""
            echo "Preview of new migration:"
            head -30 "$NEW_MIGRATIONS_FILE"
            echo "SKIP_MIGRATION=false" >> $GITHUB_ENV
          fi
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}

      - name: Deploy Supabase changes
        run: |
          # Active migration files after generation
          echo "Production migration files:"
          ls -la supabase/migrations/*.sql 2>/dev/null || echo "No migration files found"
          
          # Link to remote Supabase project with password
          echo "Linking to Supabase production project..."
          supabase link --project-ref ${{ secrets.SUPABASE_PROJECT_REF }} --password ${{ secrets.SUPABASE_DB_PASSWORD }}
          
          # Verify which project we're connected to
          echo "Verifying Supabase project connection..."
          supabase status | grep "Project ref:" || echo "Could not determine project ref"
          echo "Target project ref should be: rewepsqarjbdjvfyuvnu"
          
          # Apply database migrations with comprehensive error handling
          echo "Applying fresh database migrations to production..."
          
          # Check if there are any migrations to apply
          if [ "$SKIP_MIGRATION" = "true" ]; then
            echo "No new migrations to apply - skipping database migration step"
          elif ls supabase/migrations/*.sql 1> /dev/null 2>&1; then
            echo "Found new migrations, proceeding with deployment..."
            
            # Apply the new migration
            echo "Applying new migrations to production..."
            if echo "y" | supabase db push --linked 2>&1 | tee migration_output.log; then
              echo "New migrations applied successfully!"
            else
              echo "Migration failed. Check the logs above for specific errors"
              echo "Deployment will continue with edge functions"
            fi
          else
            echo "No migration files found - skipping database migration step"
          fi
          
          # Deploy edge functions (run regardless of migration status)
          echo "Deploying edge functions..."
          echo "Checking for edge functions..."
          if [ -d "supabase/functions" ] && [ "$(ls -A supabase/functions 2>/dev/null)" ]; then
            echo "Found edge functions directory with content"
            ls -la supabase/functions/
            
            # Deploy all functions with detailed output
            supabase functions deploy --no-verify-jwt --debug || {
              echo "Function deployment failed, trying individual function deployment..."
              
              # Try deploying each function individually
              for func_dir in supabase/functions/*/; do
                if [ -d "$func_dir" ]; then
                  func_name=$(basename "$func_dir")
                  echo "Deploying function: $func_name"
                  supabase functions deploy "$func_name" --no-verify-jwt || echo "Failed to deploy $func_name"
                fi
              done
            }
          else
            echo "No edge functions found in supabase/functions directory"
          fi
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}

      - name: Deployment Summary
        run: |
          echo "Deployment Status:"
          if [ "$GIT_CHANGES" = "false" ]; then
            echo "No Git changes detected between dev and main"
            if ls supabase/migrations/*.sql 1> /dev/null 2>&1; then
              echo "But schema migrations were generated and applied"
            else
              echo "No schema changes detected either"
            fi
          else
            echo "Merged dev to main"
            echo "Applied manual schema fixes and filtered out old problematic migrations"
            echo "Applied remaining Supabase migrations"
            echo "Deployed edge functions"
            echo "Vercel will auto-deploy from main branch"
            
            echo ""
            echo "Migration Summary:"
            if ls supabase/migrations/*.sql 1> /dev/null 2>&1; then
              echo "Migrations deployed to production:"
              ls supabase/migrations/*.sql | while read file; do
                echo "  Applied: $(basename "$file")"
              done
            else
              echo "  No new migrations were deployed"
            fi
          fi
