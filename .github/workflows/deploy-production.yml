name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      confirm_merge:
        description: 'Merge dev to main and deploy to production?'
        required: true
        default: 'no'
        type: choice
        options:
        - 'yes'
        - 'no'

permissions:
  contents: write
  pull-requests: write
  actions: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: github.event.inputs.confirm_merge == 'yes'
    
    steps:
      - name: Checkout dev branch
        uses: actions/checkout@v4
        with:
          ref: dev
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

      - name: Merge dev to main
        run: |
          # Switch to main branch
          git checkout main
          git pull origin main
          
          # Check if there are any differences between dev and main
          if git diff --quiet origin/main origin/dev; then
            echo "â„¹ï¸ No Git changes between dev and main branches"
            echo "GIT_CHANGES=false" >> $GITHUB_ENV
          else
            echo "ðŸ“ Git changes detected - proceeding with merge"
            echo "GIT_CHANGES=true" >> $GITHUB_ENV
            
            # Merge dev into main without committing, excluding client.ts
            git merge origin/dev --no-ff --no-commit || {
              echo "Merge conflict detected, resolving automatically..."
              
              # For workflow file conflicts, use the dev version
              if [ -f .github/workflows/deploy-production.yml ]; then
                git checkout --theirs .github/workflows/deploy-production.yml
              fi
              
              # Mark conflicts as resolved
              git add .
            }
            
            # Restore client.ts from main branch (exclude it from merge)
            git checkout HEAD -- src/integrations/supabase/client.ts 2>/dev/null || echo "client.ts not found, continuing..."
            
            # Check if there are still changes to commit after excluding client.ts
            if git diff --cached --quiet; then
              echo "â„¹ï¸ No changes to commit after excluding client.ts"
              git reset --hard HEAD
              echo "GIT_CHANGES=false" >> $GITHUB_ENV
            else
              # Complete the merge commit
              git commit -m "Deploy: Merge dev to main via GitHub Actions (excluding client.ts)"
              
              # Push the merge to main
              git push origin main
              
              echo "âœ… Successfully merged dev to main (excluding client.ts)"
            fi
          fi

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Generate production migrations from schema diff
        run: |
          echo "ðŸ”„ Generating fresh production migrations..."
          
          # Link to production project first
          supabase link --project-ref ${{ secrets.SUPABASE_PROJECT_REF }} --password ${{ secrets.SUPABASE_DB_PASSWORD }}
          
          # Verify connection
          echo "ðŸ” Connected to Supabase project:"
          supabase status | grep "Project ref:" || echo "Could not determine project ref"
          
          # Clear any existing migrations to start fresh
          rm -rf supabase/migrations/*.sql 2>/dev/null || true
          
          # Get current production schema
          supabase db dump --schema-only > current_production_schema.sql
          
          # Apply all Lovable schema changes to a temporary local database
          supabase start
          
          # Apply Lovable migrations to local DB to get target schema
          LOVABLE_MIGRATIONS=(
            "20250918074207_0258b852-8862-4150-8cbc-384a9e6c43cb.sql"
            "20250918074237_74ef5b91-7fc2-4c35-934f-684b67292966.sql"
            "20250918125854_5081e749-b6e7-4977-82ab-7da135f383e9.sql"
            "20250918125944_80a00b8f-5d52-43e3-9264-6d96b4c7477e.sql"
            "20250918131943_0588c8dd-9a54-445d-9a85-d761c397d1a3.sql"
            "20250919061724_7b49fea0-2b74-4270-94e9-cccb58cbeb2f.sql"
            "20250919062053_eeac2bf2-282c-4ed4-8315-c36adc38996d.sql"
            "20250919103815_522897f1-3472-4db4-a7ed-4fc3b9a6bf44.sql"
            "20250919110317_351a29f5-b66f-4ecc-8e4f-3de455b747cc.sql"
            "20250919122604_212669c5-f35d-4264-8c33-1d6b5bf1a838.sql"
            "20250920053439_c61950e0-3a0d-414c-b3af-f1e9dd4283d6.sql"
            "20250920053538_752bfdb8-9c94-4aad-8c26-c5217aa652e9.sql"
            "20250922132920_0a9ef401-3c95-4f7f-8a36-a783bc7bafea.sql"
            "20250922141031_777b7076-3302-46a4-997a-da1f7e12e4dd.sql"
            "20250923072701_7eda6fb1-00a5-4fc9-8140-4285e3a7e1d0.sql"
            "20250923121928_d8316df0-0a14-4a42-901d-ab9484ff7a72.sql"
            "20250923142916_725a545f-5a64-4376-b72f-6141d6709635.sql"
            "20250923143352_ee273e9a-f65c-4871-b2f7-c7e8ba0e085b.sql"
            "20250924111937_8cc0a6fd-a4fe-4979-bc97-d95e73a9ef35.sql"
          )
          
          # Create a single migration file with all the schema changes we want
          echo "-- Production schema sync generated $(date)" > supabase/migrations/$(date +%Y%m%d%H%M%S)_production_sync.sql
          
          # Extract just the SQL content from recent migrations (skip the older problematic ones)
          for migration_file in supabase/migrations/2025092[2-4]*.sql; do
            if [ -f "$migration_file" ]; then
              echo "-- From $(basename "$migration_file")" >> supabase/migrations/$(date +%Y%m%d%H%M%S)_production_sync.sql
              cat "$migration_file" >> supabase/migrations/$(date +%Y%m%d%H%M%S)_production_sync.sql
              echo "" >> supabase/migrations/$(date +%Y%m%d%H%M%S)_production_sync.sql
            fi
          done
          
          echo "âœ… Generated production migration file"
          ls -la supabase/migrations/

      - name: Deploy Supabase changes
        run: |
          # Active migration files after generation
          echo "Production migration files:"
          ls -la supabase/migrations/*.sql 2>/dev/null || echo "No migration files found"
          
          # Link to remote Supabase project with password
          echo "Linking to Supabase production project..."
          supabase link --project-ref ${{ secrets.SUPABASE_PROJECT_REF }} --password ${{ secrets.SUPABASE_DB_PASSWORD }}
          
          # Verify which project we're connected to
          echo "ðŸ” Verifying Supabase project connection..."
          supabase status | grep "Project ref:" || echo "Could not determine project ref"
          echo "Target project ref should be: rewepsqarjbdjvfyuvnu"
          
          # Apply database migrations with comprehensive error handling
          echo "Applying fresh database migrations to production..."
          
          # Check if there are any migrations to apply
          if ls supabase/migrations/*.sql 1> /dev/null 2>&1; then
            echo "Found generated migrations, proceeding with deployment..."
            
            # Apply the fresh migration directly (no version conflicts)
            echo "Applying new migration to production..."
            if echo "y" | supabase db push --linked 2>&1 | tee migration_output.log; then
              echo "âœ… Production migration applied successfully!"
            else
              echo "âŒ Migration failed. Check the logs above for specific errors"
              echo "âš ï¸ Deployment will continue with edge functions"
            fi
          else
            echo "â„¹ï¸ No migration files generated - skipping database migration step"
          fi
          
          # Deploy edge functions (run regardless of migration status)
          echo "Deploying edge functions..."
          echo "Checking for edge functions..."
          if [ -d "supabase/functions" ] && [ "$(ls -A supabase/functions 2>/dev/null)" ]; then
            echo "Found edge functions directory with content"
            ls -la supabase/functions/
            
            # Deploy all functions with detailed output
            supabase functions deploy --no-verify-jwt --debug || {
              echo "Function deployment failed, trying individual function deployment..."
              
              # Try deploying each function individually
              for func_dir in supabase/functions/*/; do
                if [ -d "$func_dir" ]; then
                  func_name=$(basename "$func_dir")
                  echo "Deploying function: $func_name"
                  supabase functions deploy "$func_name" --no-verify-jwt || echo "Failed to deploy $func_name"
                fi
              done
            }
          else
            echo "No edge functions found in supabase/functions directory"
          fi
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}

      - name: Deployment Summary
        run: |
          echo "ðŸš€ Deployment Status:"
          if [ "$GIT_CHANGES" = "false" ]; then
            echo "â„¹ï¸  No Git changes detected between dev and main"
            if ls supabase/migrations/*.sql 1> /dev/null 2>&1; then
              echo "âœ… But schema migrations were generated and applied"
            else
              echo "â„¹ï¸  No schema changes detected either"
            fi
          else
            echo "âœ… Merged dev â†’ main"
            echo "ðŸš« Generated fresh production migration (bypassing Lovable migration conflicts)"
            echo "âœ… Applied remaining Supabase migrations"
            echo "âœ… Deployed edge functions"
            echo "ðŸ”„ Vercel will auto-deploy from main branch"
            
            echo ""
            echo "ðŸ“‹ Migration Summary:"
            if ls supabase/migrations/*.sql 1> /dev/null 2>&1; then
              echo "Migrations deployed to production:"
              ls supabase/migrations/*.sql | while read file; do
                echo "  âœ… $(basename "$file")"
              done
            else
              echo "  â†’ No new migrations were deployed"
            fi
          fi
